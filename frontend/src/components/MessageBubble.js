/**
 * MessageBubble Component
 * Individual message display component with enhanced features
 */

import messageFormatter from '../services/messageFormatter.js';

class MessageBubble {
    constructor(message, type, metadata = {}) {
        this.message = message;
        this.type = type; // 'user', 'bot', 'crisis', 'system'
        this.metadata = metadata;
        this.id = metadata.id || messageFormatter.generateMessageId();
        this.timestamp = metadata.timestamp || new Date();
        
        this.element = null;
        this.render();
    }

    /**
     * Render the message bubble
     */
    render() {
        this.element = document.createElement('div');
        this.element.className = `message ${this.type}`;
        this.element.dataset.messageId = this.id;
        this.element.dataset.timestamp = this.timestamp.toISOString();
        
        const formattedContent = messageFormatter.formatMessage(this.message, true);
        const timeStr = messageFormatter.formatTimestamp(this.timestamp);
        
        this.element.innerHTML = `
            <div class="message-bubble" role="article" aria-label="${this.type} message">
                <div class="message-content">
                    ${formattedContent}
                </div>
                ${this.renderMetadata()}
                ${this.renderActions()}
                <div class="message-time" title="${this.timestamp.toLocaleString()}">
                    ${timeStr}
                </div>
            </div>
        `;
        
        this.bindEvents();
        return this.element;
    }

    /**
     * Render message metadata (crisis indicators, confidence, etc.)
     */
    renderMetadata() {
        if (!this.metadata || this.type === 'user') return '';
        
        let metadataHtml = '';
        
        // Crisis confidence indicator
        if (this.metadata.isCrisis && this.metadata.confidence) {
            const confidencePercent = Math.round(this.metadata.confidence * 100);
            metadataHtml += `
                <div class="message-metadata">
                    <span class="crisis-indicator" title="Crisis detected with ${confidencePercent}% confidence">
                        ‚ö†Ô∏è Crisis Alert (${confidencePercent}%)
                    </span>
                </div>
            `;
        }
        
        // AI model indicator for demo
        if (this.metadata.model) {
            metadataHtml += `
                <div class="model-indicator" title="Generated by ${this.metadata.model}">
                    <small>ü§ñ ${this.metadata.model}</small>
                </div>
            `;
        }
        
        return metadataHtml;
    }

    /**
     * Render message actions (copy, feedback, etc.)
     */
    renderActions() {
        if (this.type === 'system') return '';
        
        return `
            <div class="message-actions">
                <button class="action-btn copy-btn" title="Copy message" aria-label="Copy message">
                    üìã
                </button>
                ${this.type === 'bot' ? this.renderFeedbackActions() : ''}
                ${this.type === 'user' ? this.renderEditAction() : ''}
            </div>
        `;
    }

    /**
     * Render feedback actions for bot messages
     */
    renderFeedbackActions() {
        return `
            <button class="action-btn feedback-btn helpful" 
                    title="This was helpful" 
                    aria-label="Mark as helpful"
                    data-feedback="helpful">
                üëç
            </button>
            <button class="action-btn feedback-btn not-helpful" 
                    title="This was not helpful" 
                    aria-label="Mark as not helpful"
                    data-feedback="not_helpful">
                üëé
            </button>
        `;
    }

    /**
     * Render edit action for user messages
     */
    renderEditAction() {
        return `
            <button class="action-btn edit-btn" 
                    title="Edit message" 
                    aria-label="Edit message">
                ‚úèÔ∏è
            </button>
        `;
    }

    /**
     * Bind event handlers
     */
    bindEvents() {
        // Copy message
        const copyBtn = this.element.querySelector('.copy-btn');
        if (copyBtn) {
            copyBtn.addEventListener('click', () => this.copyMessage());
        }

        // Feedback buttons
        const feedbackBtns = this.element.querySelectorAll('.feedback-btn');
        feedbackBtns.forEach(btn => {
            btn.addEventListener('click', (e) => this.handleFeedback(e.target.dataset.feedback));
        });

        // Edit button
        const editBtn = this.element.querySelector('.edit-btn');
        if (editBtn) {
            editBtn.addEventListener('click', () => this.editMessage());
        }

        // Long press for mobile context menu
        let pressTimer;
        this.element.addEventListener('touchstart', (e) => {
            pressTimer = setTimeout(() => this.showContextMenu(e), 500);
        });
        
        this.element.addEventListener('touchend', () => {
            clearTimeout(pressTimer);
        });
        
        this.element.addEventListener('touchmove', () => {
            clearTimeout(pressTimer);
        });
    }

    /**
     * Copy message content to clipboard
     */
    async copyMessage() {
        try {
            await navigator.clipboard.writeText(this.message);
            this.showFeedback('Copied!', 'success');
        } catch (error) {
            console.error('Copy failed:', error);
            this.showFeedback('Copy failed', 'error');
        }
    }

    /**
     * Handle feedback submission
     */
    async handleFeedback(feedback) {
        try {
            // Visual feedback
            const btn = this.element.querySelector(`[data-feedback="${feedback}"]`);
            btn.classList.add('active');
            
            // Disable both feedback buttons
            this.element.querySelectorAll('.feedback-btn').forEach(b => {
                b.disabled = true;
                b.style.opacity = '0.5';
            });
            
            // Here you would typically send feedback to API
            // await apiService.sendFeedback(userId, this.id, feedback);
            
            this.showFeedback('Thank you for your feedback!', 'success');
            
        } catch (error) {
            console.error('Feedback submission failed:', error);
            this.showFeedback('Feedback failed', 'error');
            
            // Re-enable buttons on error
            this.element.querySelectorAll('.feedback-btn').forEach(b => {
                b.disabled = false;
                b.style.opacity = '1';
            });
        }
    }

    /**
     * Edit message (for user messages)
     */
    editMessage() {
        const contentEl = this.element.querySelector('.message-content');
        const currentText = this.message;
        
        // Create edit input
        const editInput = document.createElement('textarea');
        editInput.className = 'edit-input';
        editInput.value = currentText;
        editInput.style.width = '100%';
        editInput.style.minHeight = '60px';
        editInput.style.resize = 'vertical';
        
        // Create edit controls
        const editControls = document.createElement('div');
        editControls.className = 'edit-controls';
        editControls.innerHTML = `
            <button class="btn btn-sm btn-primary save-edit">Save</button>
            <button class="btn btn-sm btn-outline cancel-edit">Cancel</button>
        `;
        
        // Replace content with edit interface
        contentEl.innerHTML = '';
        contentEl.appendChild(editInput);
        contentEl.appendChild(editControls);
        
        // Focus and select text
        editInput.focus();
        editInput.select();
        
        // Bind edit controls
        editControls.querySelector('.save-edit').addEventListener('click', () => {
            const newText = editInput.value.trim();
            if (newText && newText !== currentText) {
                this.message = newText;
                this.renderContent();
                this.dispatchEvent('message-edited', { id: this.id, newText });
            } else {
                this.renderContent();
            }
        });
        
        editControls.querySelector('.cancel-edit').addEventListener('click', () => {
            this.renderContent();
        });
        
        // Save on Ctrl+Enter
        editInput.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                editControls.querySelector('.save-edit').click();
            } else if (e.key === 'Escape') {
                editControls.querySelector('.cancel-edit').click();
            }
        });
    }

    /**
     * Re-render just the content area
     */
    renderContent() {
        const contentEl = this.element.querySelector('.message-content');
        contentEl.innerHTML = messageFormatter.formatMessage(this.message, true);
    }

    /**
     * Show temporary feedback message
     */
    showFeedback(message, type = 'info') {
        const feedback = document.createElement('div');
        feedback.className = `feedback-toast ${type}`;
        feedback.textContent = message;
        feedback.style.cssText = `
            position: absolute;
            top: -30px;
            right: 0;
            background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        `;
        
        this.element.style.position = 'relative';
        this.element.appendChild(feedback);
        
        setTimeout(() => {
            feedback.remove();
        }, 2000);
    }

    /**
     * Show context menu for mobile
     */
    showContextMenu(e) {
        e.preventDefault();
        
        const menu = document.createElement('div');
        menu.className = 'context-menu';
        menu.innerHTML = `
            <button class="context-item" data-action="copy">Copy</button>
            ${this.type === 'bot' ? '<button class="context-item" data-action="feedback">Feedback</button>' : ''}
            ${this.type === 'user' ? '<button class="context-item" data-action="edit">Edit</button>' : ''}
        `;
        
        // Position menu
        const rect = this.element.getBoundingClientRect();
        menu.style.cssText = `
            position: fixed;
            top: ${rect.top - 10}px;
            left: ${rect.left}px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 2000;
        `;
        
        document.body.appendChild(menu);
        
        // Handle menu actions
        menu.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (action === 'copy') this.copyMessage();
            else if (action === 'edit') this.editMessage();
            menu.remove();
        });
        
        // Remove on outside click
        setTimeout(() => {
            document.addEventListener('click', () => menu.remove(), { once: true });
        }, 100);
    }

    /**
     * Dispatch custom events
     */
    dispatchEvent(eventName, detail) {
        const event = new CustomEvent(eventName, { detail });
        this.element.dispatchEvent(event);
    }

    /**
     * Update message content
     */
    updateContent(newContent) {
        this.message = newContent;
        this.renderContent();
    }

    /**
     * Add CSS class to message
     */
    addClass(className) {
        this.element.classList.add(className);
    }

    /**
     * Remove CSS class from message
     */
    removeClass(className) {
        this.element.classList.remove(className);
    }

    /**
     * Get message element
     */
    getElement() {
        return this.element;
    }

    /**
     * Get message data
     */
    getData() {
        return {
            id: this.id,
            message: this.message,
            type: this.type,
            timestamp: this.timestamp,
            metadata: this.metadata
        };
    }
}

export default MessageBubble;
